我仔细审阅了PR的描述和所有相关评论，包括机器人对每次修改的总结，以全面理解本次PR的核心动机和技术决策。基于这些信息，我总结了PR的发起原因、读写全工/半全工的取舍方案，以及关于禁止捕获关键异常类型的最终决策，并提供了相应的规范文档。

---

### 本次PR的发起原因

本次PR旨在解决 `ConnectionException` 在内部控制流和应用层错误之间模糊使用的问题，这种模糊性可能导致事件循环中的潜在死锁和不清晰的用户交互。核心目标是将
`ConnectionException` 重新定义为内部控制流异常，并引入事件驱动的生命周期回调（`onClose`、`onReadableEnd`、`onWritableEnd`
），以提供清晰的连接状态管理和健壮的错误处理。

### 读写全工/半全工的取舍方案

为了更好地管理连接状态，特别是半关闭场景，PR引入了 `onClose`、`onReadableEnd` 和 `onWritableEnd` 这三个事件驱动的生命周期回调。

- `onReadableEnd` 和 `onWritableEnd` 专门用于处理连接的读端或写端关闭的半关闭情况。这使得反应器能够在发生致命I/O错误时可靠地终止连接，同时通过明确的事件通知用户连接的单向关闭状态。
- 这种方案提供了比单一 `ConnectionException` 更细粒度和明确的连接状态管理方式，增强了系统的健壮性。

### 禁止捕获的关键异常类型的最终决策

核心决策是明确区分内部控制流异常和应用层错误。

- `ConnectionException` 现在专门用于反应器内部的控制流。
- 引入了 `TransportException` 来处理更广泛的传输层错误，取代了许多之前 `ConnectionException` 的用法。
- `TransportTimeoutException` 被添加用于特定的SSL握手超时，提供更精确的错误区分。
- `AbortConnection` 接口作为标记接口，用于表示那些旨在中止连接的异常，这些异常对于反应器的内部状态管理至关重要。
- **最终决策**: 这些内部控制流异常（`ConnectionException`、`TransportException`、`TransportTimeoutException` 以及任何实现
  `AbortConnection` 接口的异常）主要用于反应器的内部逻辑。应用程序代码通常**不应直接捕获**
  这些特定异常，以避免干扰反应器终止连接和管理状态的内部逻辑。相反，应用程序应依赖新的事件驱动回调（`onClose`、
  `onReadableEnd`、`onWritableEnd`）来获取连接状态变化和错误通知。如果应用程序确实需要捕获它们（例如，用于日志记录），则在处理后必须重新抛出它们，以确保反应器的控制流不被中断。

### 规范文档

#### 连接生命周期和错误处理指南

本次PR优化了连接生命周期事件和错误的处理方式，旨在构建一个更健壮、可预测的系统。

- **事件驱动的生命周期**:
    - 不再依赖异常来处理连接状态变化，而是使用新的事件驱动回调：
        - `onClose()`: 当连接完全关闭时触发。
        - `onReadableEnd()`: 当连接的读端关闭时触发（半关闭）。
        - `onWritableEnd()`: 当连接的写端关闭时触发（半关闭）。
    - 这些回调为连接状态转换（包括半关闭场景）提供了明确的通知，从而实现精确的资源管理和用户交互。

- **异常处理**:
    - **内部控制流异常**: `ConnectionException`、`TransportException`、`TransportTimeoutException` 以及任何实现
      `AbortConnection` 接口的异常，主要用于反应器的内部控制流。
    - **通常不应捕获**: 应用程序级别的代码通常应**避免直接捕获**这些特定异常。捕获它们可能会干扰反应器终止连接和管理状态的内部逻辑，从而可能导致死锁或状态不一致。
    - **依赖回调**: 对于与连接终止相关的应用层错误处理，请依赖 `onClose` 回调，它将在反应器处理完内部异常后触发。
    - **特定用例**: 如果应用程序**必须**捕获这些异常（例如，用于特定的日志记录或调试），则在处理后重新抛出它们至关重要，以确保反应器能够完成其预期的控制流。不要抑制这些异常。

这种方法确保了反应器能够可靠地管理I/O错误和连接状态，同时为用户提供了清晰的、基于事件的机制来响应连接生命周期事件。
